<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Screw 0.3.1 Demo</title>
  <style>
	body {
		margin:0;
		padding:0;
		background:#AAAAAA;
		display:flex;
		align-items:center;
		justify-content:center;
		width:100vw;
		height:100vh;
		overflow-x:hidden;
	}
	canvas {
		background:black;
	}
  </style>
</head>
<body>
  <canvas width='1000' height='1000'></canvas>
  <script>
//Screw v0.3.1 demo
//Programmed by Lucas Lux
//10/1/25

//needs z-index thingy
class screwElement{
	constructor(ctx=null,x=0,y=0,options={}){
		this.ctx = ctx;
		this.x = x;
		this.y = y;
		this.children = [];
		this.intersected = false;
		this.parent = null;
		this.enabled = options.enabled ?? true;
		this.visible = options.visible ?? true;
		this.cvis = options.cvis ?? true;
		this.cena = options.cena ?? true;
		this.style = options.style ?? [];
		this.props = options.props ?? new Map();
		for(let i=0;i<this.style.length;i++){
			if(this.style[i].constructor.name != 'Map'){
				this.style[i] = new Map(Object.entries(this.style[i]));
			}
		}
		if(this.props.constructor.name != 'Map'){
			this.props = new Map(Object.entries(this.props));
		}
	}
	addChild(e){
		this.children.push(e);
		e.parent = this;
	}
	removeChild(ind){
		this.children[ind].parent = null;
		this.children.splice(i,1);
	}
	changeStyle(ind,v){
		this.style[ind] = v.constructor.name === 'Map' ? v : new Map(Object.entries(v));
	}
	setProp(k,v){
		return this.props.set(k,v).get(k);
	}
	getProp(k){
		return this.props.get(k);
	}
	processStyle(ind){
		if(this.style[ind]){
			for(const [k,v] of this.style[ind]){
				switch(k){
					case 'setLineDash':
					this.ctx.setLineDash(v);
					break;
					case 'setTransform':
					this.ctx.setTransform(v);
					break;
					default:
					this.ctx[k] = v;
				}
			}
		}
	}
	getOffset(x=0,y=0){
		let pc = [this.x+x,this.y+y];
		let p = this.parent;
		while(p != null){
			pc[0]+=p.x;
			pc[1]+=p.y;
			p = p.parent;
		}
		return pc;
	}
	render(x=0,y=0){
		if(this.visible && this.cvis){
			this.renderChildren(x,y);
		}
	}
	renderChildren(x=0,y=0){
		for(let i=0;i<this.children.length;i++){
			this.children[i].render(x,y);
		}
	}
	intersect(cx,cy){
		return false;
	}
	intersectChildren(cx,cy){
		for(let i=0;i<this.children.length;i++){
			if(this.children[i].intersect(cx,cy)){
				return true;
			}
		}
		return false;
	}
}
class screwGroup extends screwElement{
	constructor(ctx,x,y,options={}){
		super(ctx,x,y,options);
	}
	intersect(cx,cy){
		if(this.enabled && this.cena && this.children.length > 0){
			this.intersected = this.intersectChildren(cx,cy)
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwRectInt extends screwElement{
	constructor(ctx,x,y,w,h,options={}){
		super(ctx,x,y,options);
		this.w = w;
		this.h = h;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = cx >= rc[0] && cx <= rc[0]+this.w && cy >= rc[1] && cy <= rc[1]+this.h;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwSqInt extends screwElement{
	constructor(ctx,x,y,l,options={}){
		super(ctx,x,y,options);
		this.l = l;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = cx >= rc[0] && cx <= rc[0]+this.l && cy >= rc[1] && cy <= rc[1]+this.l;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwCircInt extends screwElement{
	constructor(ctx,x,y,r,options={}){
		super(ctx,x,y,options);
		this.r = r;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = Math.hypot(rc[0]-cx,rc[1]-cy) <= this.r;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwElliInt extends screwElement{
	constructor(ctx,x,y,hr,vr,options={}){
		super(ctx,x,y,options);
		this.hr = hr;
		this.vr = vr;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			const c1 = (cx-rc[0]);
			const c2 = (cy-rc[1]);
			this.intersected = ((c1*c1)/(this.hr*this.hr))+((c2*c2)/(this.vr*this.vr)) <= 1;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwLineInt extends screwElement{
	constructor(ctx,bx,by,ex,ey,options={}){
		super(ctx,bx,by,options);
		this.ex = ex;
		this.ey = ey;
		this.r = options.r || 5;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.parent.getOffset();
			const a = (this.ey-this.y);
			const b = (this.ex-this.x);
			if(a == 0){
				//no rise
				let	rbx = this.x;
				let	rex = this.ex;
				if(rbx > rex){
					rbx = this.ex;
					rex = this.x;
				}
				rex = cx-(rex+rc[0]);
				rbx = cx-(rbx+rc[0]);
				const d = cy-(rc[1]+this.y);
				if(rex > 0){
					this.intersected = (rex*rex)+(d*d) <= this.r*this.r;
				}else if(rbx < 0){
					this.intersected = (rbx*rbx)+(d*d) <= this.r*this.r;
				}else{
					this.intersected = Math.abs(d) <= this.r;
				}
			}else if(b == 0){
				//no run
				let	rby = this.y;
				let	rey = this.ey;
				if(rby > rey){
					rby = this.ey;
					rey = this.y;
				}
				rey = cy-(rey+rc[1]);
				rby = cy-(rby+rc[1]);
				const d = cx-(rc[0]+this.x);
				if(rey > 0){
					this.intersected = (rey*rey)+(d*d) <= this.r*this.r;
				}else if(rby < 0){
					this.intersected = (rby*rby)+(d*d) <= this.r*this.r;
				}else{
					this.intersected = Math.abs(d) <= this.r;
				}
			}else{
				const rx = this.x+rc[0];
				const ry = this.y+rc[1];
				let	rbx = rx;
				let	rex = this.ex+rc[0];
				if(this.x > this.ex){
					rbx = rex;
					rex = rx;
				}
				const sl = a/b;
				const int = Math.min(Math.max((((1/sl)*cx)+cy-ry+(sl*rx))/((1/sl)+sl),rbx),rex);
				const c1 = cx-int;
				const c2 = cy-((sl*(int-rx))+ry);
				this.intersected = (c1*c1)+(c2*c2) <= this.r*this.r;
			}
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwTexInt extends screwElement{
	constructor(ctx,x,y,t,options={}){
		super(ctx,x,y,options);
		this.t = t;
		this.style.length < 1 && this.style.push(new Map());
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.parent.getOffset();
			cx = cx-rc[0];
			cy = cy-rc[1];
			this.ctx.save();
			this.processStyle(0);
			const m = this.ctx.measureText(this.t);
			this.ctx.restore();
			//(this.max ? this.max : m.width)
			this.intersected = (cx >= this.x-m.actualBoundingBoxLeft && cx <= this.x+m.actualBoundingBoxRight) && (cy <= this.y+m.actualBoundingBoxDescent && cy >= this.y-m.actualBoundingBoxAscent);
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwTex extends screwTexInt{
	constructor(ctx,x,y,t,options={}){
		super(ctx,x,y,t,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.style.length < 2 && this.style.push(new Map());
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			this.ctx.save();
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fillText(this.t,rc[0],rc[1]);
			}
			if(this.svis){
				this.processStyle(1);
				this.ctx.strokeText(this.t,rc[0],rc[1]);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwRect extends screwRectInt{
	constructor(ctx,x,y,w,h,options={}){
		super(ctx,x,y,w,h,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			this.ctx.save();
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fillRect(rc[0],rc[1],this.w,this.h);
			}
			if(this.svis){
				this.processStyle(1);
				this.ctx.strokeRect(rc[0],rc[1],this.w,this.h);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwLine extends screwLineInt{
	constructor(ctx,bx,by,ex,ey,options={}){
		super(ctx,bx,by,ex,ey,options);
		this.style.length < 1 && this.style.push(new Map());
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.parent.getOffset(x,y);
			this.ctx.save();
			this.processStyle(0);
			this.ctx.beginPath();
			this.ctx.moveTo(this.x+rc[0],this.y+rc[1]);
			this.ctx.lineTo(this.ex+rc[0],this.ey+rc[1]);
			this.ctx.stroke();
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwSq extends screwSqInt{
	constructor(ctx,x,y,l,options={}){
		super(ctx,x,y,l,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			this.ctx.save();
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fillRect(rc[0],rc[1],this.l,this.l);
			}
			if(this.svis){
				this.processStyle(1);
				this.ctx.strokeRect(rc[0],rc[1],this.l,this.l);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwCirc extends screwCircInt{
	constructor(ctx,x,y,r,options={}){
		super(ctx,x,y,r,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			this.ctx.save();
			base.arc(rc[0],rc[1],this.r,0,2*Math.PI);
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fill(base);
			}
			if(this.svis){
				this.processStyle(1);
				this.ctx.stroke(base);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwElli extends screwElliInt{
	constructor(ctx,x,y,hr,vr,options={}){
		super(ctx,x,y,hr,vr,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			this.ctx.save();
			base.ellipse(rc[0],rc[1],this.hr,this.vr,0,0,2*Math.PI);
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fill(base);
			}
			if(this.svis){
				this.processStyle(1);
				this.ctx.stroke(base);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwRoundRect extends screwRectInt{
	constructor(ctx,x,y,w,h,r,options={}){
		super(ctx,x,y,w,h,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.r = r;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			this.ctx.save();
			if(this.r==0){
				base.rect(rc[0],rc[1],this.w,this.h);
			}else{
				base.roundRect(rc[0],rc[1],this.w,this.h,this.r);
			}
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fill(base);
			}
			if(this.svis){
				this.processStyle(1);
				this.ctx.stroke(base);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
const canv = document.getElementsByTagName('canvas')[0];
const ctx = canv.getContext('2d');
const rect = new screwRoundRect(ctx,10,10,80,50,0,{svis:false,style:[{fillStyle:'red'},{strokeStyle:'white',lineWidth:3}]});
const line = new screwGroup(ctx,300,300);
const main = new screwGroup(ctx,200,200);
const circ = new screwCirc(ctx,100,200,25,{svis:false,style:[{fillStyle:'blue'},{strokeStyle:'white',lineWidth:5}]});
const elli = new screwElli(ctx,10,300,50,25,{svis:false,style:[{fillStyle:'green'},{strokeStyle:'red',lineWidth:5}]});
const txt = new screwTex(ctx,300,300,'Testing...',{svis:false,style:[{font:'bold 48px sans-serif',fillStyle:'#FE854A',textAlign:'center',textBaseline:'middle'},{strokeStyle:'lightblue'}]});
const cont1 = new screwCirc(ctx,25,-50,5,{visible:false,enabled:false,svis:false,style:[{fillStyle:'white'},{strokeStyle:'#3EA0FC',lineWidth:2}]});
const cont2 = new screwCirc(ctx,-25,50,5,{visible:false,enabled:false,svis:false,style:[{fillStyle:'white'},{strokeStyle:'#3EA0FC',lineWidth:2}]});
const rectcont = new screwCirc(ctx,0,0,5,{visible:false,enabled:false,svis:false,style:[{fillStyle:'green'},{strokeStyle:'white',lineWidth:2}]});
rect.addChild(rectcont);
main.addChild(rect);
main.addChild(line);
main.addChild(circ);
main.addChild(elli);
main.addChild(txt);
const linestyle = new Map();
linestyle.set('strokeStyle','white');
linestyle.set('lineWidth',2);
line.addChild(new screwLine(ctx,25,-50,-25,50,{style:[linestyle],r:10}));
line.addChild(new screwLine(ctx,25,-50,50,-50,{style:[linestyle],r:10}));
line.addChild(new screwLine(ctx,-25,50,-50,50,{style:[linestyle],r:10}));
line.addChild(cont1);
line.addChild(cont2);
main.render();
canv.addEventListener('mousedown',e=>{
	if(rectcont.setProp('clicked',rectcont.intersect(e.offsetX,e.offsetY))){
		rectcont.svis = true;
	}else if(rect.setProp('clicked',rect.intersect(e.offsetX,e.offsetY))){
		rect.svis = true;
	}else if(cont1.setProp('clicked',cont1.intersect(e.offsetX,e.offsetY))){
		cont1.svis = true;
	}else if(cont2.setProp('clicked',cont2.intersect(e.offsetX,e.offsetY))){
		cont2.svis = true;
	}else if(line.setProp('clicked',line.intersect(e.offsetX,e.offsetY))){
		for(let i=0;i<line.children.length;i++){
			if(line.children[i].constructor.name == 'screwLine'){
				line.children[i].style[0].set('strokeStyle','green');
			};
		}
	}else if(circ.setProp('clicked',circ.intersect(e.offsetX,e.offsetY))){
		circ.svis = true;
	}else if(elli.setProp('clicked',elli.intersect(e.offsetX,e.offsetY))){
		elli.svis = true;
	}else if(txt.setProp('clicked',txt.intersect(e.offsetX,e.offsetY))){
		txt.style[0].set('font','italic 48px serif');
		txt.svis = true;
	}
	ctx.reset();
	main.render();
});
document.addEventListener('mouseup',e=>{
	rect.setProp('clicked',false);
	line.setProp('clicked',false);
	circ.setProp('clicked',false);
	elli.setProp('clicked',false);
	txt.setProp('clicked',false);
	cont1.setProp('clicked',false);
	cont2.setProp('clicked',false);
	rectcont.setProp('clicked',false);
	for(let i=0;i<line.children.length;i++){
		if(line.children[i].constructor.name == 'screwLine'){
			line.children[i].style[0].set('strokeStyle','white');
		};
	}
	circ.svis = false;
	rect.svis = false;
	elli.svis = false;
	cont1.svis = false;
	cont2.svis = false;
	rectcont.svis = false;
	txt.style[0].set('font','bold 48px sans-serif');
	txt.svis = false;
	ctx.reset();
	main.render();
});
canv.addEventListener('mousemove',e=>{
	if(rectcont.getProp('clicked')){
		rectcont.x = Math.min(Math.max(rectcont.x+e.movementX,0),rect.w/2);
		rect.r = rectcont.x;
	}else if(rect.getProp('clicked')){
		rect.x += e.movementX;
		rect.y += e.movementY;
	}else if(cont1.getProp('clicked')){
		cont1.x += e.movementX;
		cont1.y += e.movementY;
		line.children[0].x = line.children[1].x = cont1.x
		line.children[0].y = line.children[1].y = cont1.y
		line.children[1].ex += e.movementX;
		line.children[1].ey += e.movementY;
	}else if(cont2.getProp('clicked')){
		cont2.x += e.movementX;
		cont2.y += e.movementY;
		line.children[0].ex = line.children[2].x = cont2.x
		line.children[0].ey = line.children[2].y = cont2.y
		line.children[2].ex += e.movementX;
		line.children[2].ey += e.movementY;
	}else if(line.getProp('clicked')){
		line.x += e.movementX;
		line.y += e.movementY;
	}else if(circ.getProp('clicked')){
		circ.x += e.movementX;
		circ.y += e.movementY;
	}else if(elli.getProp('clicked')){
		elli.x += e.movementX;
		elli.y += e.movementY;
	}else if(txt.getProp('clicked')){
		txt.x += e.movementX;
		txt.y += e.movementY;
	}
	if(line.intersect(e.offsetX,e.offsetY)){
		line.children[3].visible = line.children[4].visible = line.children[3].enabled = line.children[4].enabled = true;
	}else{
		line.children[3].visible = line.children[4].visible = line.children[3].enabled = line.children[4].enabled = false;
	}
	if(rect.intersect(e.offsetX,e.offsetY)){
		rectcont.visible = rectcont.enabled = true;
	}else{
		rectcont.visible = rectcont.enabled = false;
	}
	ctx.reset();
	main.render();
});
  </script>
</body>
</html>
