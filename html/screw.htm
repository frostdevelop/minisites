<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Screw 0.2 Demo</title>
  <style>
	body {
		margin:0;
		padding:0;
		background:#AAAAAA;
		display:flex;
		align-items:center;
		justify-content:center;
		width:100vw;
		height:100vh;
		overflow-x:hidden;
	}
	canvas {
		background:black;
	}
  </style>
</head>
<body>
  <canvas width='1000' height='1000'></canvas>
  <script>
//Screw v0.2 demo
//Programmed by Lucas Lux
//10/1/25

//adding a parent argument would be kinda useless since addChild is still needed
class screwElement{
	constructor(can,ctx=null,x=0,y=0,options={}){
		this.can = can;
		this.ctx = ctx;
		this.x = x;
		this.y = y;
		this.children = [];
		this.intersected = false;
		this.parent = null;
		this.enabled = options.enabled ?? true;
		this.visible = options.visible ?? true;
		this.cvis = options.cvis ?? true;
		this.cena = options.cena ?? true;
	}
	addChild(e){
		this.children.push(e);
		e.parent = this;
	}
	removeChild(i){
		this.children[i].parent = null;
		this.children.splice(i,1);
	}
	getOffset(x=0,y=0){
		//I don't feel like implementing this as a iterative thingy for every inheritor :sob:
		//const pc = this.parent ? this.parent.getOffset() : [0,0];
		let pc = [this.x+x,this.y+y];
		let p = this.parent;
		while(p != null){
			pc[0]+=p.x;
			pc[1]+=p.y;
			p = p.parent;
		}
		return pc;
	}
	render(x=0,y=0){
		if(this.visible && this.cvis){
			this.renderChildren(x,y);
		}
	}
	renderChildren(x=0,y=0){
		for(let i=0;i<this.children.length;i++){
			this.children[i].render(x,y);
		}
	}
	intersect(cx,cy){
		return false;
	}
	intersectChildren(cx,cy){
		for(let i=0;i<this.children.length;i++){
			if(this.children[i].intersect(cx,cy)){
				return true;
			}
		}
		return false;
	}
}
class screwGroup extends screwElement{
	constructor(can,ctx,x,y,options={}){
		super(can,ctx,x,y,options);
	}
	intersect(cx,cy){
		if(this.enabled && this.cena){
			this.intersected = this.intersectChildren(cx,cy)
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwRectInt extends screwElement{
	constructor(can,ctx,x,y,w,h,options={}){
		super(can,ctx,x,y,options);
		this.w = w;
		this.h = h;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = cx >= rc[0] && cx <= rc[0]+this.w && cy >= rc[1] && cy <= rc[1]+this.h;
			if(!this.intersected && this.cena){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwSqInt extends screwElement{
	constructor(can,ctx,x,y,l,options={}){
		super(can,ctx,x,y,options);
		this.l = l;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = cx >= rc[0] && cx <= rc[0]+this.l && cy >= rc[1] && cy <= rc[1]+this.l;
			if(!this.intersected && this.cena){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwCircInt extends screwElement{
	constructor(can,ctx,x,y,r,options={}){
		super(can,ctx,x,y,options);
		this.r = r;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = Math.hypot(rc[0]-cx,rc[1]-cy) <= this.r;
			if(!this.intersected && this.cena){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwElliInt extends screwElement{
	constructor(can,ctx,x,y,hr,vr,options={}){
		super(can,ctx,x,y,options);
		this.hr = hr;
		this.vr = vr;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			const c1 = (cx-rc[0]);
			const c2 = (cy-rc[1]);
			this.intersected = ((c1*c1)/(this.hr*this.hr))+((c2*c2)/(this.vr*this.vr)) <= 1;
			if(!this.intersected && this.cena){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwLineInt extends screwElement{
	constructor(can,ctx,bx,by,ex,ey,options={}){
		super(can,ctx,bx,by,options);
		this.ex = ex;
		this.ey = ey;
		this.r = options.r || 5;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.parent.getOffset();
			const a = (this.ey-this.y);
			const b = (this.ex-this.x);
			if(a == 0){
				//no rise
				let	rbx = this.x;
				let	rex = this.ex;
				if(rbx > rex){
					rbx = this.ex;
					rex = this.x;
				}
				rex = cx-(rex+rc[0]);
				rbx = cx-(rbx+rc[0]);
				const d = cy-(rc[1]+this.y);
				if(rex > 0){
					this.intersected = (rex*rex)+(d*d) <= this.r*this.r;
				}else if(rbx < 0){
					this.intersected = (rbx*rbx)+(d*d) <= this.r*this.r;
				}else{
					this.intersected = Math.abs(d) <= this.r;
				}
			}else if(b == 0){
				//no run
				let	rby = this.y;
				let	rey = this.ey;
				if(rby > rey){
					rby = this.ey;
					rey = this.y;
				}
				rey = cy-(rey+rc[1]);
				rby = cy-(rby+rc[1]);
				const d = cx-(rc[0]+this.x);
				if(rey > 0){
					this.intersected = (rey*rey)+(d*d) <= this.r*this.r;
				}else if(rby < 0){
					this.intersected = (rby*rby)+(d*d) <= this.r*this.r;
				}else{
					this.intersected = Math.abs(d) <= this.r;
				}
			}else{
				const rx = this.x+rc[0];
				const ry = this.y+rc[1];
				let	rbx = rx;
				let	rex = this.ex+rc[0];
				if(this.x > this.ex){
					rbx = rex;
					rex = rx;
				}
				const sl = a/b;
				const int = Math.min(Math.max((((1/sl)*cx)+cy-ry+(sl*rx))/((1/sl)+sl),rbx),rex);
				const c1 = cx-int;
				const c2 = cy-((sl*(int-rx))+ry);
				this.intersected = (c1*c1)+(c2*c2) <= this.r*this.r;
			}
			if(!this.intersected && this.cena){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwTexInt extends screwElement{
	constructor(can,ctx,x,y,t,fnt,options={}){
		super(can,ctx,x,y,options);
		this.t = t;
		this.fnt = fnt;
		this.ta = options.ta || 'left';
		this.tb = options.tb || 'alphabetic';
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.parent.getOffset();
			cx = cx-rc[0];
			cy = cy-rc[1];
			this.ctx.textAlign = this.ta;
			this.ctx.textBaseline = this.tb;
			this.ctx.font = this.fnt;
			const m = this.ctx.measureText(this.t);
			//(this.max ? this.max : m.width)
			this.intersected = (cx >= this.x-m.actualBoundingBoxLeft && cx <= this.x+m.actualBoundingBoxRight) && (cy <= this.y+m.actualBoundingBoxDescent && cy >= this.y-m.actualBoundingBoxAscent);
			if(!this.intersected && this.cena){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
//was originally going to be responsive but has problems with scaling and stuff
class screwTex extends screwTexInt{
	constructor(can,ctx,x,y,t,fnt,options={}){
		super(can,ctx,x,y,t,fnt,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.sty = options.sty;
		this.ssty = options.ssty;
		this.slw = options.slw || 1;
		this.slj = options.slj || 'miter';
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			this.ctx.font = this.fnt;
			this.ctx.textAlign = this.ta;
			this.ctx.textBaseline = this.tb;
			if(this.fvis && this.sty){
				this.ctx.fillStyle = this.sty;
				this.ctx.fillText(this.t,rc[0],rc[1]);
			}
			if(this.svis && this.ssty){
				this.ctx.lineWidth = this.slw;
				this.ctx.lineJoin = this.slj;
				this.ctx.strokeStyle = this.ssty;
				this.ctx.strokeText(this.t,rc[0],rc[1]);
			}
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwRect extends screwRectInt{
	constructor(can,ctx,x,y,w,h,options){
		super(can,ctx,x,y,w,h);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.sty = options.sty;
		this.ssty = options.ssty;
		this.slw = options.slw || 1;
		this.slj = options.slj || 'miter';
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			if(this.fvis && this.sty){
				this.ctx.fillStyle = this.sty;
				this.ctx.fillRect(rc[0],rc[1],this.w,this.h);
			}
			if(this.svis && this.ssty){
				this.ctx.lineWidth = this.slw;
				this.ctx.lineJoin = this.slj;
				this.ctx.strokeStyle = this.ssty;
				this.ctx.strokeRect(rc[0],rc[1],this.w,this.h);
			}
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwLine extends screwLineInt{
	constructor(can,ctx,bx,by,ex,ey,options={}){
		super(can,ctx,bx,by,ex,ey,options);
		this.sty = options.sty || 'white';
		this.lw = options.lw || 1;
		this.lj = options.lj || 'miter';
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.parent.getOffset(x,y);
			this.ctx.lineWidth = this.lw;
			this.ctx.lineJoin = this.lj;
			this.ctx.strokeStyle = this.sty;
			this.ctx.beginPath();
			this.ctx.moveTo(this.x+rc[0],this.y+rc[1]);
			this.ctx.lineTo(this.ex+rc[0],this.ey+rc[1]);
			this.ctx.stroke();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwSq extends screwSqInt{
	constructor(can,ctx,x,y,l,options={}){
		super(can,ctx,x,y,l,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.sty = options.sty;
		this.ssty = options.ssty;
		this.slw = options.slw || 1;
		this.slj = options.slj || 'miter';
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			if(this.fvis && this.sty){
				this.ctx.fillStyle = this.sty;
				this.ctx.fillRect(rc[0],rc[1],this.l,this.l);
			}
			if(this.svis && this.ssty){
				this.ctx.lineWidth = this.slw;
				this.ctx.lineJoin = this.slj;
				this.ctx.strokeStyle = this.ssty;
				this.ctx.strokeRect(rc[0],rc[1],this.l,this.l);
			}
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwCirc extends screwCircInt{
	constructor(can,ctx,x,y,r,options={}){
		super(can,ctx,x,y,r,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.sty = options.sty;
		this.ssty = options.ssty;
		this.slw = options.slw || 1;
		this.slj = options.slj || 'miter';
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			base.arc(rc[0],rc[1],this.r,0,2*Math.PI);
			if(this.fvis && this.sty){
				this.ctx.fillStyle = this.sty;
				this.ctx.fill(base);
			}
			if(this.svis && this.ssty){
				this.ctx.lineWidth = this.slw;
				this.ctx.lineJoin = this.slj;
				this.ctx.strokeStyle = this.ssty;
				this.ctx.stroke(base);
			}
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwElli extends screwElliInt{
	constructor(can,ctx,x,y,hr,vr,options={}){
		super(can,ctx,x,y,hr,vr,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.sty = options.sty;
		this.ssty = options.ssty;
		this.slw = options.slw || 1;
		this.slj = options.slj || 'miter';
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			base.ellipse(rc[0],rc[1],this.hr,this.vr,0,0,2*Math.PI);
			if(this.fvis && this.sty){
				this.ctx.fillStyle = this.sty;
				this.ctx.fill(base);
			}
			if(this.svis && this.ssty){
				this.ctx.lineWidth = this.slw;
				this.ctx.lineJoin = this.slj;
				this.ctx.strokeStyle = this.ssty;
				this.ctx.stroke(base);
			}
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwRoundRect extends screwRectInt{
	constructor(can,ctx,x,y,w,h,r,options={}){
		super(can,ctx,x,y,w,h,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.r = r;
		this.sty = options.sty;
		this.ssty = options.ssty;
		this.slw = options.slw || 1;
		this.slj = options.slj || 'miter';
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			if(this.r==0){
				base.rect(rc[0],rc[1],this.w,this.h);
			}else{
				base.roundRect(rc[0],rc[1],this.w,this.h,this.r);
			}
			if(this.fvis && this.sty){
				this.ctx.fillStyle = this.sty;
				this.ctx.fill(base);
			}
			if(this.svis && this.ssty){
				this.ctx.lineWidth = this.slw;
				this.ctx.lineJoin = this.slj;
				this.ctx.strokeStyle = this.ssty;
				this.ctx.stroke(base);
			}
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
const canv = document.getElementsByTagName('canvas')[0];
const ctx = canv.getContext('2d');
const rect = new screwRoundRect(canv,ctx,10,10,80,50,0,{sty:'red',ssty:'white',slw:3,svis:false});
const line = new screwGroup(canv,ctx,300,300);
const main = new screwGroup(canv,ctx,200,200);
const circ = new screwCirc(canv,ctx,100,200,25,{sty:'blue',slw:5,ssty:'white',svis:false});
const elli = new screwElli(canv,ctx,10,300,50,25,{sty:'green',slw:5,ssty:'red',svis:false});
const txt = new screwTex(canv,ctx,300,300,'Testing...','bold 48px sans-serif',{sty: '#FE854A',ta:'center',tb:'middle',ssty:'lightblue',svis:false});
const cont1 = new screwCirc(canv,ctx,25,-50,5,{sty:'white',slw:2,visible:false,enabled:false,ssty:'#3EA0FC',svis:false});
const cont2 = new screwCirc(canv,ctx,-25,50,5,{sty:'white',slw:2,visible:false,enabled:false,ssty:'#3EA0FC',svis:false});
const rectcont = new screwCirc(canv,ctx,0,0,5,{sty:'green',slw:2,visible:false,enabled:false,ssty:'white',svis:false});
rect.addChild(rectcont);
main.addChild(rect);
main.addChild(line);
main.addChild(circ);
main.addChild(elli);
main.addChild(txt);
line.addChild(new screwLine(canv,ctx,25,-50,-25,50,10,'white',2));
line.addChild(new screwLine(canv,ctx,25,-50,50,-50,10,'white',2));
line.addChild(new screwLine(canv,ctx,-25,50,-50,50,10,'white',2));
line.addChild(cont1);
line.addChild(cont2);
main.render();
canv.addEventListener('mousedown',e=>{
	if(rectcont.clicked = rectcont.intersect(e.offsetX,e.offsetY)){
		rectcont.svis = true;
	}else if(rect.clicked = rect.intersect(e.offsetX,e.offsetY)){
		rect.svis = true;
	}else if(cont1.clicked = cont1.intersect(e.offsetX,e.offsetY)){
		cont1.svis = true;
	}else if(cont2.clicked = cont2.intersect(e.offsetX,e.offsetY)){
		cont2.svis = true;
	}else if(line.clicked = line.intersect(e.offsetX,e.offsetY)){
		for(let i=0;i<line.children.length;i++){
			line.children[i].sty = 'green';
		}
	}else if(circ.clicked = circ.intersect(e.offsetX,e.offsetY)){
		circ.svis = true;
	}else if(elli.clicked = elli.intersect(e.offsetX,e.offsetY)){
		elli.svis = true;
	}else if(txt.clicked = txt.intersect(e.offsetX,e.offsetY)){
		txt.fnt = 'italic 48px serif';
		txt.svis = true;
	}
	ctx.reset();
	main.render();
});
document.addEventListener('mouseup',e=>{
	rect.clicked = false;
	line.clicked = false;
	circ.clicked = false;
	elli.clicked = false;
	txt.clicked = false;
	cont1.clicked = false;
	cont2.clicked = false;
	rectcont.clicked = false;
	for(let i=0;i<line.children.length;i++){
	  line.children[i].sty = 'white';
	}
	circ.svis = false;
	rect.svis = false;
	elli.svis = false;
	cont1.svis = false;
	cont2.svis = false;
	rectcont.svis = false;
	txt.fnt = 'bold 48px sans-serif';
	txt.svis = false;
	ctx.reset();
	main.render();
});
canv.addEventListener('mousemove',e=>{
	if(rectcont.clicked){
		rectcont.x = Math.min(Math.max(rectcont.x+e.movementX,0),rect.w/2);
		rect.r = rectcont.x;
	}else if(rect.clicked){
		rect.x += e.movementX;
		rect.y += e.movementY;
	}else if(cont1.clicked){
		cont1.x += e.movementX;
		cont1.y += e.movementY;
		line.children[0].x = line.children[1].x = cont1.x
		line.children[0].y = line.children[1].y = cont1.y
		line.children[1].ex += e.movementX;
		line.children[1].ey += e.movementY;
	}else if(cont2.clicked){
		cont2.x += e.movementX;
		cont2.y += e.movementY;
		line.children[0].ex = line.children[2].x = cont2.x
		line.children[0].ey = line.children[2].y = cont2.y
		line.children[2].ex += e.movementX;
		line.children[2].ey += e.movementY;
	}else if(line.clicked){
		line.x += e.movementX;
		line.y += e.movementY;
	}else if(circ.clicked){
		circ.x += e.movementX;
		circ.y += e.movementY;
	}else if(elli.clicked){
		elli.x += e.movementX;
		elli.y += e.movementY;
	}else if(txt.clicked){
		txt.x += e.movementX;
		txt.y += e.movementY;
	}
	if(line.intersect(e.offsetX,e.offsetY)){
		line.children[3].visible = line.children[4].visible = line.children[3].enabled = line.children[4].enabled = true;
	}else{
		line.children[3].visible = line.children[4].visible = line.children[3].enabled = line.children[4].enabled = false;
	}
	if(rect.intersect(e.offsetX,e.offsetY)){
		rectcont.visible = rectcont.enabled = true;
	}else{
		rectcont.visible = rectcont.enabled = false;
	}
	ctx.reset();
	main.render();
});
  </script>
</body>
</html>
