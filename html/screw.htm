<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Screw 0.3 Demo</title>
  <style>
	body {
		margin:0;
		padding:0;
		background:#AAAAAA;
		display:flex;
		align-items:center;
		justify-content:center;
		width:100vw;
		height:100vh;
		overflow-x:hidden;
	}
	canvas {
		background:black;
	}
  </style>
</head>
<body>
  <canvas width='1000' height='1000'></canvas>
  <script>
//Screw v0.3 demo
//Programmed by Lucas Lux
//10/1/25

class screwElement{
	constructor(ctx=null,x=0,y=0,options={}){//,style nahh would be too tedious and stupid with the intersection classes
		this.ctx = ctx;
		this.x = x;
		this.y = y;
		this.children = [];
		this.intersected = false;
		this.parent = null;
		this.enabled = options.enabled ?? true;
		this.visible = options.visible ?? true;
		this.cvis = options.cvis ?? true;
		this.cena = options.cena ?? true;
		this.style = options.style ?? []; //[map]
		//this.prevStyle = null; I'M STUPID LOL
	}
	addChild(e){
		this.children.push(e);
		e.parent = this;
	}
	removeChild(i){
		this.children[i].parent = null;
		this.children.splice(i,1);
	}
	processStyle(ind){//,sav=true
		if(this.style[ind]){
			/*
			if(sav){
				this.prevStyle = new Map();
				for(const [k,v] of this.style[ind]){
					switch(k){
						case 'setLineDash':
						this.prevStyle.set(k,this.ctx.getLineDash());
						this.ctx.setLineDash(v);
						break;
						case 'setTransform':
						this.prevStyle.set(k,this.ctx.getTransform());
						this.ctx.setTransform(v);
						break;
						default:
						this.prevStyle.set(k,this.ctx[k]);
						this.ctx[k] = v;
					}
				}
			}else{
			}
			*/
			for(const [k,v] of this.style[ind]){
				switch(k){
					case 'setLineDash':
					this.ctx.setLineDash(v);
					break;
					case 'setTransform':
					this.ctx.setTransform(v);
					break;
					default:
					this.ctx[k] = v;
				}
			}
		}
	}
	/*
	restoreStyle(){
		if(this.prevStyle)
	}
	*/
	getOffset(x=0,y=0){
		let pc = [this.x+x,this.y+y];
		let p = this.parent;
		while(p != null){
			pc[0]+=p.x;
			pc[1]+=p.y;
			p = p.parent;
		}
		return pc;
	}
	render(x=0,y=0){
		if(this.visible && this.cvis){
			this.renderChildren(x,y);
		}
	}
	renderChildren(x=0,y=0){
		for(let i=0;i<this.children.length;i++){
			this.children[i].render(x,y);
		}
	}
	intersect(cx,cy){
		return false;
	}
	intersectChildren(cx,cy){
		for(let i=0;i<this.children.length;i++){
			if(this.children[i].intersect(cx,cy)){
				return true;
			}
		}
		return false;
	}
}
class screwGroup extends screwElement{
	constructor(ctx,x,y,options={}){
		super(ctx,x,y,options);
	}
	intersect(cx,cy){
		if(this.enabled && this.cena && this.children.length > 0){
			this.intersected = this.intersectChildren(cx,cy)
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwRectInt extends screwElement{
	constructor(ctx,x,y,w,h,options={}){
		super(ctx,x,y,options);
		this.w = w;
		this.h = h;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = cx >= rc[0] && cx <= rc[0]+this.w && cy >= rc[1] && cy <= rc[1]+this.h;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwSqInt extends screwElement{
	constructor(ctx,x,y,l,options={}){
		super(ctx,x,y,options);
		this.l = l;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = cx >= rc[0] && cx <= rc[0]+this.l && cy >= rc[1] && cy <= rc[1]+this.l;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwCircInt extends screwElement{
	constructor(ctx,x,y,r,options={}){
		super(ctx,x,y,options);
		this.r = r;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			this.intersected = Math.hypot(rc[0]-cx,rc[1]-cy) <= this.r;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwElliInt extends screwElement{
	constructor(ctx,x,y,hr,vr,options={}){
		super(ctx,x,y,options);
		this.hr = hr;
		this.vr = vr;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.getOffset();
			const c1 = (cx-rc[0]);
			const c2 = (cy-rc[1]);
			this.intersected = ((c1*c1)/(this.hr*this.hr))+((c2*c2)/(this.vr*this.vr)) <= 1;
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwLineInt extends screwElement{
	constructor(ctx,bx,by,ex,ey,options={}){
		super(ctx,bx,by,options);
		this.ex = ex;
		this.ey = ey;
		this.r = options.r || 5;
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.parent.getOffset();
			const a = (this.ey-this.y);
			const b = (this.ex-this.x);
			if(a == 0){
				//no rise
				let	rbx = this.x;
				let	rex = this.ex;
				if(rbx > rex){
					rbx = this.ex;
					rex = this.x;
				}
				rex = cx-(rex+rc[0]);
				rbx = cx-(rbx+rc[0]);
				const d = cy-(rc[1]+this.y);
				if(rex > 0){
					this.intersected = (rex*rex)+(d*d) <= this.r*this.r;
				}else if(rbx < 0){
					this.intersected = (rbx*rbx)+(d*d) <= this.r*this.r;
				}else{
					this.intersected = Math.abs(d) <= this.r;
				}
			}else if(b == 0){
				//no run
				let	rby = this.y;
				let	rey = this.ey;
				if(rby > rey){
					rby = this.ey;
					rey = this.y;
				}
				rey = cy-(rey+rc[1]);
				rby = cy-(rby+rc[1]);
				const d = cx-(rc[0]+this.x);
				if(rey > 0){
					this.intersected = (rey*rey)+(d*d) <= this.r*this.r;
				}else if(rby < 0){
					this.intersected = (rby*rby)+(d*d) <= this.r*this.r;
				}else{
					this.intersected = Math.abs(d) <= this.r;
				}
			}else{
				const rx = this.x+rc[0];
				const ry = this.y+rc[1];
				let	rbx = rx;
				let	rex = this.ex+rc[0];
				if(this.x > this.ex){
					rbx = rex;
					rex = rx;
				}
				const sl = a/b;
				const int = Math.min(Math.max((((1/sl)*cx)+cy-ry+(sl*rx))/((1/sl)+sl),rbx),rex);
				const c1 = cx-int;
				const c2 = cy-((sl*(int-rx))+ry);
				this.intersected = (c1*c1)+(c2*c2) <= this.r*this.r;
			}
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
class screwTexInt extends screwElement{
	constructor(ctx,x,y,t,options={}){
		super(ctx,x,y,options);
		this.t = t;
		this.style.length < 1 && this.style.push(new Map());
	}
	intersect(cx,cy){
		if(this.enabled){
			const rc = this.parent.getOffset();
			cx = cx-rc[0];
			cy = cy-rc[1];
			this.ctx.save();
			this.processStyle(0);
			const m = this.ctx.measureText(this.t);
			this.ctx.restore();
			//(this.max ? this.max : m.width)
			this.intersected = (cx >= this.x-m.actualBoundingBoxLeft && cx <= this.x+m.actualBoundingBoxRight) && (cy <= this.y+m.actualBoundingBoxDescent && cy >= this.y-m.actualBoundingBoxAscent);
			if(!this.intersected && this.cena && this.children.length > 0){
				this.intersected = this.intersectChildren(cx,cy);
			}
			return this.intersected;
		}else{
			return false;
		}
	}
}
//was originally going to be responsive but has problems with scaling and stuff
class screwTex extends screwTexInt{
	constructor(ctx,x,y,t,options={}){
		super(ctx,x,y,t,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.style.length < 2 && this.style.push(new Map());
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			this.ctx.save();
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fillText(this.t,rc[0],rc[1]);
			}
			//this.ctx.restore();
			if(this.svis){
				this.processStyle(1);
				this.ctx.strokeText(this.t,rc[0],rc[1]);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwRect extends screwRectInt{
	constructor(ctx,x,y,w,h,options={}){
		super(ctx,x,y,w,h,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			this.ctx.save();
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fillRect(rc[0],rc[1],this.w,this.h);
			}
			//this.ctx.restore();
			if(this.svis){
				this.processStyle(1);
				this.ctx.strokeRect(rc[0],rc[1],this.w,this.h);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwLine extends screwLineInt{
	constructor(ctx,bx,by,ex,ey,options={}){
		super(ctx,bx,by,ex,ey,options);
		this.style.length < 1 && this.style.push(new Map());
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.parent.getOffset(x,y);
			this.ctx.save();
			this.processStyle(0);
			this.ctx.beginPath();
			this.ctx.moveTo(this.x+rc[0],this.y+rc[1]);
			this.ctx.lineTo(this.ex+rc[0],this.ey+rc[1]);
			this.ctx.stroke();
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwSq extends screwSqInt{
	constructor(ctx,x,y,l,options={}){
		super(ctx,x,y,l,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			this.ctx.save();
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fillRect(rc[0],rc[1],this.l,this.l);
			}
			//this.ctx.restore();
			if(this.svis){
				this.processStyle(1);
				this.ctx.strokeRect(rc[0],rc[1],this.l,this.l);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwCirc extends screwCircInt{
	constructor(ctx,x,y,r,options={}){
		super(ctx,x,y,r,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			this.ctx.save();
			base.arc(rc[0],rc[1],this.r,0,2*Math.PI);
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fill(base);
			}
			//this.ctx.restore();
			if(this.svis){
				this.processStyle(1);
				this.ctx.stroke(base);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwElli extends screwElliInt{
	constructor(ctx,x,y,hr,vr,options={}){
		super(ctx,x,y,hr,vr,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			this.ctx.save();
			base.ellipse(rc[0],rc[1],this.hr,this.vr,0,0,2*Math.PI);
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fill(base);
			}
			//this.ctx.restore();
			if(this.svis){
				this.processStyle(1);
				this.ctx.stroke(base);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
class screwRoundRect extends screwRectInt{
	constructor(ctx,x,y,w,h,r,options={}){
		super(ctx,x,y,w,h,options);
		this.fvis = options.fvis ?? true;
		this.svis = options.svis ?? true;
		this.r = r;
		for(let i=this.style.length;i<2;i++){
			this.style.push(new Map());
		}
	}
	render(x=0,y=0){
		if(this.visible){
			const rc = this.getOffset(x,y);
			const base = new Path2D();
			this.ctx.save();
			if(this.r==0){
				base.rect(rc[0],rc[1],this.w,this.h);
			}else{
				base.roundRect(rc[0],rc[1],this.w,this.h,this.r);
			}
			if(this.fvis){
				this.processStyle(0);
				this.ctx.fill(base);
			}
			//this.ctx.restore();
			if(this.svis){
				this.processStyle(1);
				this.ctx.stroke(base);
			}
			this.ctx.restore();
			if(this.cvis){
				this.renderChildren(x,y);
			}
		}
	}
}
const canv = document.getElementsByTagName('canvas')[0];
const ctx = canv.getContext('2d');
const rect = new screwRoundRect(ctx,10,10,80,50,0,{svis:false});
rect.style[0].set('fillStyle','red');
rect.style[1].set('strokeStyle','white');
rect.style[1].set('lineWidth',3);
const line = new screwGroup(ctx,300,300);
const main = new screwGroup(ctx,200,200);
const circ = new screwCirc(ctx,100,200,25,{svis:false});
circ.style[0].set('fillStyle','blue');
circ.style[1].set('strokeStyle','white');
circ.style[1].set('lineWidth',5);
const elli = new screwElli(ctx,10,300,50,25,{svis:false});
elli.style[0].set('fillStyle','green');
elli.style[1].set('strokeStyle','red');
elli.style[1].set('lineWidth',5);
const txt = new screwTex(ctx,300,300,'Testing...',{svis:false});
txt.style[0].set('font','bold 48px sans-serif');
txt.style[0].set('fillStyle','#FE854A');
txt.style[0].set('textAlign','center');
txt.style[0].set('textBaseline','middle');
txt.style[1].set('strokeStyle','lightblue');
const cont1 = new screwCirc(ctx,25,-50,5,{visible:false,enabled:false,svis:false});
cont1.style[0].set('fillStyle','white');
cont1.style[1].set('lineWidth',2);
cont1.style[1].set('strokeStyle','#3EA0FC');
const cont2 = new screwCirc(ctx,-25,50,5,{visible:false,enabled:false,svis:false});
cont2.style[0].set('fillStyle','white');
cont2.style[1].set('lineWidth',2);
cont2.style[1].set('strokeStyle','#3EA0FC');
const rectcont = new screwCirc(ctx,0,0,5,{visible:false,enabled:false,svis:false});
rectcont.style[0].set('fillStyle','green');
rectcont.style[1].set('lineWidth',2);
rectcont.style[1].set('strokeStyle','white');
rect.addChild(rectcont);
main.addChild(rect);
main.addChild(line);
main.addChild(circ);
main.addChild(elli);
main.addChild(txt);
const linestyle = new Map();
linestyle.set('strokeStyle','white');
linestyle.set('lineWidth',2);
line.addChild(new screwLine(ctx,25,-50,-25,50,{style:[linestyle],r:10}));
line.addChild(new screwLine(ctx,25,-50,50,-50,{style:[linestyle],r:10}));
line.addChild(new screwLine(ctx,-25,50,-50,50,{style:[linestyle],r:10}));
line.addChild(cont1);
line.addChild(cont2);
main.render();
canv.addEventListener('mousedown',e=>{
	if(rectcont.clicked = rectcont.intersect(e.offsetX,e.offsetY)){
		rectcont.svis = true;
	}else if(rect.clicked = rect.intersect(e.offsetX,e.offsetY)){
		rect.svis = true;
	}else if(cont1.clicked = cont1.intersect(e.offsetX,e.offsetY)){
		cont1.svis = true;
	}else if(cont2.clicked = cont2.intersect(e.offsetX,e.offsetY)){
		cont2.svis = true;
	}else if(line.clicked = line.intersect(e.offsetX,e.offsetY)){
		for(let i=0;i<line.children.length;i++){
			if(line.children[i].constructor.name == 'screwLine'){
				line.children[i].style[0].set('strokeStyle','green');
			};
		}
	}else if(circ.clicked = circ.intersect(e.offsetX,e.offsetY)){
		circ.svis = true;
	}else if(elli.clicked = elli.intersect(e.offsetX,e.offsetY)){
		elli.svis = true;
	}else if(txt.clicked = txt.intersect(e.offsetX,e.offsetY)){
		txt.style[0].set('font','italic 48px serif');
		txt.svis = true;
	}
	ctx.reset();
	main.render();
});
document.addEventListener('mouseup',e=>{
	rect.clicked = false;
	line.clicked = false;
	circ.clicked = false;
	elli.clicked = false;
	txt.clicked = false;
	cont1.clicked = false;
	cont2.clicked = false;
	rectcont.clicked = false;
	for(let i=0;i<line.children.length;i++){
		if(line.children[i].constructor.name == 'screwLine'){
			line.children[i].style[0].set('strokeStyle','white');
		};
	}
	circ.svis = false;
	rect.svis = false;
	elli.svis = false;
	cont1.svis = false;
	cont2.svis = false;
	rectcont.svis = false;
	txt.style[0].set('font','bold 48px sans-serif');
	txt.svis = false;
	ctx.reset();
	main.render();
});
canv.addEventListener('mousemove',e=>{
	if(rectcont.clicked){
		rectcont.x = Math.min(Math.max(rectcont.x+e.movementX,0),rect.w/2);
		rect.r = rectcont.x;
	}else if(rect.clicked){
		rect.x += e.movementX;
		rect.y += e.movementY;
	}else if(cont1.clicked){
		cont1.x += e.movementX;
		cont1.y += e.movementY;
		line.children[0].x = line.children[1].x = cont1.x
		line.children[0].y = line.children[1].y = cont1.y
		line.children[1].ex += e.movementX;
		line.children[1].ey += e.movementY;
	}else if(cont2.clicked){
		cont2.x += e.movementX;
		cont2.y += e.movementY;
		line.children[0].ex = line.children[2].x = cont2.x
		line.children[0].ey = line.children[2].y = cont2.y
		line.children[2].ex += e.movementX;
		line.children[2].ey += e.movementY;
	}else if(line.clicked){
		line.x += e.movementX;
		line.y += e.movementY;
	}else if(circ.clicked){
		circ.x += e.movementX;
		circ.y += e.movementY;
	}else if(elli.clicked){
		elli.x += e.movementX;
		elli.y += e.movementY;
	}else if(txt.clicked){
		txt.x += e.movementX;
		txt.y += e.movementY;
	}
	if(line.intersect(e.offsetX,e.offsetY)){
		line.children[3].visible = line.children[4].visible = line.children[3].enabled = line.children[4].enabled = true;
	}else{
		line.children[3].visible = line.children[4].visible = line.children[3].enabled = line.children[4].enabled = false;
	}
	if(rect.intersect(e.offsetX,e.offsetY)){
		rectcont.visible = rectcont.enabled = true;
	}else{
		rectcont.visible = rectcont.enabled = false;
	}
	ctx.reset();
	main.render();
});
  </script>
</body>
</html>
